{"meta":{"title":"Imohuan","subtitle":null,"description":"博客","author":"imohuan","url":"https://getupyouwhat.github.io"},"pages":[{"title":"分类","date":"2018-09-25T06:21:01.000Z","updated":"2018-09-26T06:48:49.897Z","comments":true,"path":"categories/index.html","permalink":"https://getupyouwhat.github.io/categories/index.html","excerpt":"","text":"分类"},{"title":"标签","date":"2018-09-26T01:48:06.000Z","updated":"2018-09-26T01:53:47.059Z","comments":true,"path":"tags/index.html","permalink":"https://getupyouwhat.github.io/tags/index.html","excerpt":"","text":"标签"}],"posts":[{"title":"webpack4-教程","slug":"webpack","date":"2018-09-27T06:18:20.000Z","updated":"2018-09-27T06:18:18.156Z","comments":true,"path":"2018/09/27/webpack/","link":"","permalink":"https://getupyouwhat.github.io/2018/09/27/webpack/","excerpt":"","text":"安装依赖 相关信息 —–&gt; 官网查询 cnpm i webpack webpack-cli webpack-dev-server style-loader css-loader less-loader url-loader file-loader 未安装css分离的配置const path = require(&quot;path&quot;); const uglify = require(&#39;uglifyjs-webpack-plugin&#39;);//JS压缩插件,对代码进行压缩 const htmlPlugin = require(&quot;html-webpack-plugin&quot;); module.exports = { mode:&quot;development&quot;, entry:{ main:&#39;./src/main.js&#39;, //main2:&#39;./src/main2.js&#39; }, output:{ path:path.resolve(__dirname,&quot;../dist&quot;), filename:&#39;[name].js&#39; }, devServer:{ contentBase:path.resolve(__dirname,&#39;../dist&#39;), //设置基本项目结构 host:&#39;localhost&#39;,//设置服务器ip或者localhost compress:true,//服务器压缩 port:8080 }, plugins:[ new uglify(),//实例化 new htmlPlugin({ minify:{ //是对html文件进行压缩 removeAttributeQuotes:true //removeAttrubuteQuotes是却掉属性的双引号。 }, hash:true, //为了开发中js有缓存效果，所以加入hash，这样可以有效避免缓存JS。 template:&#39;./src/index.html&#39; //是要打包的html模版路径和文件名称。 }) ], module:{ rules:[ { test:/\\.css$/, use:[ {loader:&quot;style-loader&quot;} , {loader:&quot;css-loader&quot;} ] },{ test:/\\.(png|jpg|gif|jpeg)/, //是匹配图片文件后缀名称 use:[{ loader:&#39;url-loader&#39;, //是指定使用的loader和loader的配置参数 options:{ limit:5000 //是把小于5000B的文件打成Base64的格式，写入JS } }] } ] } } 安装css分离依赖cnpm i extract-text-webpack-plugin 代码 如果报错 —– 原因版本和webpack版本不统一 cnpm install --save-dev extract-text-webpack-plugin@next const extractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;); plugins:[new extractTextPlugin(&quot;css/index.css&quot;)], module:{ rules:[ { test:/\\.css$/, use: extractTextPlugin.extract({ fallback: &quot;style-loader&quot;, use: &quot;css-loader&quot; }) } ] } 把相对路径转换绝对路output:{ publicPath:&quot;http://localhost:8080/&quot; //publicPath：主要作用就是处理静态文件路径的。 //http://localhost:8080/为devServer里面的本地服务地址 } 把图片放到指定的文件夹下依赖cnpm i html-withimg-loader 代码module:{ rules:[ { test: /\\.(htm|html)$/i, use:[ &#39;html-withimg-loader&#39;] },{ test:/\\.(png|jpg|gif|jpeg)/, //是匹配图片文件后缀名称 use:[{ loader:&#39;url-loader&#39;, //是指定使用的loader和loader的配置参数 options:{ limit:5000, //是把小于5000B的文件打成Base64的格式，写入JS outputPath:&#39;images/&#39;, //打包后的图片放到images文件夹下 } }] } ] } 清空缓存的dist中文件依赖cnpm i clean-webpack-plugin 代码const CleanWebpackPlugin = require(&#39;clean-webpack-plugin&#39;); plugins: [ new CleanWebpackPlugin([&quot;../dist&quot;]) ] Less文件的打包和分离依赖cnpm i less less-loader 注意: 需要在js中引入文件 如:import less from “路径”，同css一样 代码module:{ rules:[ { test: /\\.less$/, use: extractTextPlugin.extract({ use:[ {loader: &quot;css-loader&quot;}, {loader: &quot;less-loader&quot;} ], fallback: &quot;style-loader&quot; }) } ] } Sass文件的打包和分离 把上面的less全部改为Sass 自动处理CSS3属性前缀依赖cnpm i postcss-loader autoprefixer 代码刚刚失败了 消除未使用的CSS依赖 PurifyCSS-webpack要依赖于purify-css cnpm i purifycss-webpack purify-css 代码const glob = require(&#39;glob&#39;); //检查html模板 const PurifyCSSPlugin = require(&quot;purifycss-webpack&quot;); plugins:[ new PurifyCSSPlugin({ paths: glob.sync(path.join(__dirname, &#39;src/*.html&#39;)), //这里配置了一个paths，主要是需找html模板，purifycss根据这个配置会遍历你的文件， 查找哪些css被使用了。 }) ] webpack增加babel支持依赖cnpm i babel-core babel-loader babel-preset-es2015 babel-preset-react 代码module:{ rules:[ { test:/\\.(jsx|js)$/, use:{ loader:&#39;babel-loader&#39;, options:{ presets:[ &quot;es2015&quot;,&quot;react&quot; ] } }, exclude:/node_modules/ } ] } 懒 – 复制算了 babelrc配置 虽然Babel可以直接在webpack.config.js中进行配置，但是考虑到babel具有非常多的配置选项，如果卸载webapck.config.js中会非常的雍长不可阅读，所以我们经常把配置卸载.babelrc文件里。 在项目根目录新建.babelrc文件，并把配置写到文件里。 .babelrc文件下 { &quot;presets&quot;:[&quot;react&quot;,&quot;es2015&quot;] } 这时候.webpack.dev.config.js里的loader配置 //babel 配置 { test:/\\.(jsx|js)$/, use:{ loader:&#39;babel-loader&#39;, }, exclude:/node_modules/ } 18.3、 ENV： 现在网络上已经不流行babel-preset-es2015，现在官方推荐使用的是babel-preset-env,那我们为了紧跟潮流，我们在讲一下env的配置方法。 首先需要下载： npm install --save-dev babel-preset-env 然后修改.babelrc里的配置文件。其实只要把之前的es2015换成env就可以了。 { &quot;presets&quot;:[&quot;react&quot;,&quot;env&quot;] }","categories":[{"name":"前端","slug":"前端","permalink":"https://getupyouwhat.github.io/categories/前端/"}],"tags":[{"name":"分享","slug":"分享","permalink":"https://getupyouwhat.github.io/tags/分享/"},{"name":"教程","slug":"教程","permalink":"https://getupyouwhat.github.io/tags/教程/"}]},{"title":"Markdown","slug":"Markdown","date":"2018-09-26T09:13:58.000Z","updated":"2018-09-26T09:17:33.255Z","comments":true,"path":"2018/09/26/Markdown/","link":"","permalink":"https://getupyouwhat.github.io/2018/09/26/Markdown/","excerpt":"","text":"使用 Markdown 写技术博客，我踩过的 6个坑摘要：本文记录我在使用 Markdown 过程中遇到的平台语法和显示差异问题，分析常见写作平台对于 Markdown 支持的差异以及避坑建议，文中有我的思考：技术自由和标准的取舍。 Markdown 的语法特性让人们在写作的过程中只需要专注于文字内容而并不需要特别在意排版，不让思路被打断。发布的时候则是需要考虑读者看到的样式，是否美观。 Markdown 特性Markdown 简介 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的 HTML 页面。——维基百科 常用语法下图是网上流传很广的一个图,基本语法都包含了： 为什么流行 纯文本，易于编辑，跨平台支持 语法简单，易学，容读 流畅书写不干扰焦点 方便转换为 Html 和 PDF，适合网站写作，成为一种网络书写语言 支持 Html 特性，可以自定义复杂样式 最大开源网站 Github 和最大问答社区 StackOverflow 的流行，技术人领跑 移动设备普及，小尺寸阅读体验优化 设计哲学 Markdown is intended to be as easy-to-read and easy-to-write as is feasible. — By JOHN GRUBER 易读易写，很朴素的理念。专注写作，大道至简。 工具支持Markdown 是一种用来写作的轻量级「标记语言」，满足大家一处写作处处使用的梦想。目前支持 Markdown 语法的工具和产品很多，下面列举一些常见的，各人根据习惯选取，有好的推荐也请留言告知： 支持网站 GitHub StackOverflow CSDN OpenStreetMap 博客园 简书 知乎 掘金 笔记工具 印象笔记 有道云笔记 为知笔记 编辑器 Windows 平台 Typora MarkdownPad MarkPad VS Code Linux 平台 ReText Haroopad VS Code Mac 平台 Bear Mou MacDown 在线编辑器 stackedit.io Markable.in Dillinger.io maxiang.io mermaid 浏览器插件 Markdown Here 推荐使用 Visual Studio Code，作为一个全宇宙最强编辑器的延伸，插件丰富，你值得拥有。什么，不会配置，太复杂了，想要随处可用，地铁也码字？有道云笔记走起。 版本演变现在 Markdown 发展红红火火，缺点也是显而易见的，相信用过一段时间的人都有体会，槽点满满。 没有统一标准 Gruber has argued that complete standardization would be mistaken: “Different sites (and people) have different needs. No one syntax would make all happy.” 创始人对于这个问题的回应，我是不认同的。扩展性和标准并不冲突，自由也是在一定的框架内。这也就导致了第一个 Perl 版本后各种语言版本都根据一定的规则更严格的扩展了 Markdown 的语法，产生了层出不穷的工具。 编辑器和语法选择了一个顺手的编辑器，也就等于选择了一种 Markdown 语法实现。因此有特别需求的，例如流程图，生成目录，复杂表格支持，大量数学公式展示，特别需要了解编辑器支持的情况以及展示发布的站点是否支持。 标准化2016年3月 RFC 7763 提出将增加一种 MIME type 类型 text/markdown ,而 RFC 7764 则讨论了几种常见类型的Markdown 纳入到标准化： MultiMarkdown, GitHub Flavored Markdown (GFM), Pandoc, CommonMark, and Markdown Extra 。具体参考链接 Markdown Variants，这是一个可喜的进步。 拥抱变化开源的理念：允许用户通过添加扩展来提供所需的特性。但是没有一个标准，只是一个概念，不拥抱变化，那就只有淘汰了。没有哪一种技术是一开始就完善的，都是经过不断的版本迭代，服务于开发者。这也是另外一个角度看后面为何那么多变种语法都遵循了 CommonMark，包括大家熟知的 GitHub Flavored Markdown (GFM) 。 踩过的坑 开源本没有路，走的人多了，也就成了路，踩的坑多了你也就放弃了。——开源项目真实写照。 平台帮助文档必须放在第一位，没有详尽帮助文档的工具，请放弃，否则掉坑怎么都爬不出来。工具栏+预览基本都是标配，这个就没什么好说的了，想看语法就逐个点击一下就支持这个编辑器支持的基本语法，熟悉了就可以抛弃这种低效率的方式，解放拿鼠标的手。 这方面国内做的最好的是 CSDN 的编辑器。进来就是一篇例子为正文，双栏支持预览，右上角有明显问号帮助图标，点击后有分主题的帮小例子。 其次就是有道云笔记了，界面双栏预览，右上角问号帮助点击后跳转到管网帮助文档，初阶和高阶两篇，足够入门。遗憾的是文中参学习的链接已经失效，没有及时更新。 掘金文档一般，高级的用法没有说明，指向的链接已经失效，找不到是基于哪一种变种开发的，尝试了，发现公式也是支持的，脚注不支持，基本确定是类似 Pandoc，但不是 Markdown Extra 。 最差就是简书和博客园了。感受一下，博客园：虽然可以自定义丰富的 CSS 和 模板，但是后台也太丑陋了。 简书至今没有找到明显的帮助，也找不到具体实现依赖，通过粘贴几段示例验证应该是 CommonMark and Github Flavored Markdown。 语法差异语法差异其实就是看支持的是 Markdown 的哪一种实现，以及对应的配置选择。好消息就是，通用的格式 CommonMark 里面基础的标记是都支持的，只是单纯文字和图片几乎是随处可用，样式一致。 有一个专门的开源项目 Babelmark 3 是不同 Markdown 实现结果归类，目前收集了 33 个版本 目前大部分编辑工具都可以选择实现的方式，是否开启样式。网站上则是只能遵守固定的规则去修改了。 列表出现空行效果问题这是 Markdown 都存在的问题，来自定义列表时候没有严格定义这种行为处理。具体可以参见 CommonMark Spec V0.28。Markdown 常见的不小心加了空行会出现什么事情呢？导致出现不同转换 Html 的样式。不同解析器实现在转换列表里是否使用段落添加 或 出现了分歧。没有对错之分，只是符合你的需求就好，因此说最终发布需要仔细阅读调整一下很有必要，趟过一次坑基本一眼就可以找到问题。 图片插入标记属性展示问题对于下面这段 Markdown 代码： ![图片标记显示](https://ws1.sinaimg.cn/large/66cf5bc0ly1fve6pmxkfrj20u605uwet.jpg) 复制代码 对于标签里面的文字标记居然有不同的解释，分歧点在转换为 Html 是否属性也显示出来，常见的实现只有 multimarkdown 5.1.0 和 pandoc 2.3 是显示出来的。 简书的效果就是显示的，因此猜测可能是这两个实现的变种。 支持扩展效果不一致最典型的就是表格和流程图了。大部分的实现都支持表格的功能，通过 Babelmark 3 可以看到 6 种转换后的 Html，如果表格里面还使用了加粗的话更是惨不忍睹，12 种效果任君猜测在不同网站显示，你绝对想不到的。 显示效果这也是个天坑，辛苦的写好后，最终是需要面对读者的。引起的原因无非是实现的扩展功能不一致以及网站的 CSS 样式差异影响到了排版。 实现的扩展功能不一致这时候就必须要关注效果了。有预览功能那是最好的，例如 CSDN, 简书，否则需要一次次的发布然后查看，修改，例如博客园。因此选择的工具和你发布的平台的兼容性问题就来了，最好是都是同一个核心源码的变种实现。 CSS 样式差异影响对于表格功能是最为突出的。先看看效果比较： 因此建议不使用表格扩展语法，或者使用自定义css应用后转换为图片。 我的最佳实践目标就是为了一次书写，到处发布。以下的都是基于个人喜爱，仅供参考。Windows 平台下使用有道云笔记同步素材以及没有完成的文章。 写作使用 Visual Studio Code 软件 插件安装 Markdown All in One 根据需要配置想要的版本和功能支持，快捷键丰富，绝对是效率神器。建议写完后打开预览功能查看效果。 语法检查安装 markdownlint ，实时语法检查对于 IDE 来说是必备的 图床使用新浪微博或七牛云 使用 Pangu-Markdown 检查中文排版 检查中英文混排效果是否符合通用实践。 发布使用 Markdown Here 转换后查看效果是否符合意图再仔细检查后粘贴","categories":[{"name":"前端","slug":"前端","permalink":"https://getupyouwhat.github.io/categories/前端/"}],"tags":[{"name":"填坑","slug":"填坑","permalink":"https://getupyouwhat.github.io/tags/填坑/"},{"name":"分享","slug":"分享","permalink":"https://getupyouwhat.github.io/tags/分享/"}]},{"title":"Vue页面跳转动画","slug":"Vue","date":"2018-09-26T09:06:37.000Z","updated":"2018-09-26T09:17:43.060Z","comments":true,"path":"2018/09/26/Vue/","link":"","permalink":"https://getupyouwhat.github.io/2018/09/26/Vue/","excerpt":"","text":"Vue页面跳转动画效果实现前言现如今移动端APP对用户体验方面的要求越来越高了，最近致力于用户体验优化，因为需要实现类似APP页面切换的动画效果，百度google搜索资料不是很全，所以自己写文档，在实现效果的基础上，顺便恶补一波VueRouter及CSS过渡动画的知识点，欢迎有兴趣的朋友多多指教。 写在前面的思考 如何匹配到相应需要跳转的页面？ 如何判断是“前进”还是“后退”而后使用不同的动画方式？ 如何对不同的跳转设置动画效果？ 实现过程一、vue路由匹配创建vue实例，匹配路由。用Vue.js + Vue Router创建单页应用，是非常简单的。使用Vue.js，我们可以通过组合组件来组成应用程序，将Vue Router 添加进来之后，我们需要做的是，将组件(components)映射到路由(routes),然后告诉Vue Router 在哪里渲染它们。 import Vue from &#39;vue&#39; import Router from &#39;vue-router&#39; Vue.use(Router) //如果使用模块化机制编程，导入Vue和VueRouter，就需要调用Vue.use(Router) 复制代码 接下来就可以进行路由组件的映射：(路由)组件的定义可以自行定义，当然，为了践行模块化组件化思想，多是从其他文件import进来。以下以简单的“登录-&gt;主页-&gt;点单-&gt;结算”四个页面的交互为例： import Login from &#39;@/components/login&#39; import Index from &#39;@/components/index&#39; import PointList from &#39;@/components/pointList/pointList&#39; import SettLement from &#39;@/components/pointList/settlement&#39; //创建router实例，然后传入‘routes’配置 export default new Router({ //routes配置可以直接传入，也可以先定义后使用 //每个路由都应该映射一个组件，其中component可以是通过Vue.extend()创建的组件构造器， 或者只是一个组件配饰对象。(今天暂时不考虑嵌套路由的情况) routes: [ { path: &#39;/&#39;, // 登录 name: &#39;Login&#39;, component: Login }, { path: &#39;/index&#39;, // 主页 name: &#39;Index&#39;, component: Index }, { path: &#39;/pointList&#39;, // 点单 name: &#39;PointList&#39;, component: PointList }, { path: &#39;/settLement&#39;, // 结算 name: &#39;SettLement&#39;, component: SettLement } ] }) 复制代码 二、路由跳转 $router组件路由除了使用全局组件 router-link 来实现点击跳转(相当于按钮)外，还可以使用组件本身 具有的一个实例对象$router及其一些属性来达到目标。 $router 是VueRouter的一个实例对象，相当于一个全局的路由器对象。在Vue实例内部，你可以 通过$router访问路由实例，里面含有很多属性和子对象，例如history对象，经常用到的跳转链 接就可以调用this.$router.push，this.$router.push会往history栈中添加一个新记录。 复制代码 声明式 编程式 &lt;router-link :to=”…” router.push(…) 点击 等同于调用 router.push(…)(…)该方法的参数可以是一个字符串，或者一个描述地址的对象： // 字符串 router.push(&#39;home&#39;) // 对象 router.push({ path: &#39;home&#39; }) // 命名的路由 router.push({ name: &#39;user&#39;, params: { userId: 123 }}) // 带查询参数，变成 /register?plan=private router.push({ path: &#39;register&#39;, query: { plan: &#39;private&#39; }}) 复制代码 组件路由跳转实例：1. &lt;router-link :to=&quot;{name:&#39;PointList&#39;, params: { userId: 123 }}&quot;&gt; &lt;i class=&quot;icon&quot;&gt;&lt;img src=&quot;../assets/point.png&quot; alt=&quot;&quot;&gt;&lt;/i&gt; &lt;span&gt;点单&lt;/span&gt; &lt;/router-link&gt; 复制代码 &lt;footer class=&quot;version&quot; @click=&quot;goPage(&#39;Author&#39;)&quot;&gt;v 1.0&lt;/footer&gt; //Js： methods: { goPage(url, param) { this.$router.push({ name: url }); } } 复制代码 三、vue路由对象$route(只读)在使用了vue-router的应用中，路由对象会被注入每个组件中，赋值为this.$route,并且当路由切换时，路由对象会被更新。所以route相当于当前正在跳转的路由对象，可以从里面获取name,path,params,query等，即包含了当前URL解析得到的信息，还有URL匹配到的路由记录。路由对象暴露了以下属性(常见)： $route.path 字符串(string)。等于当前路由对象的路径，会被解析为绝对路径， 如:http://example.com/#/login?name=aa，this.$route.path ，输出“/login”，即对应上面1中路由匹配时routes配置中的“path”； 复制代码 $route.name字符串(string)。有时候，通过一个名称来标识一个路由显得更加方便，特别是在链接一个路由，或者是执行一些跳转的时候。同样，这里的name也对应了routes配置中给某个路由设置名称的name值：要链接到一个命名路由，可以给router-link的to属性传一个对象： &lt;router-link :to=&quot;{name:&#39;Order&#39;, params: { userId: 123 }}&quot;&gt; &lt;/router-link&gt; 复制代码 用在调用router.push()中也是一回事： this.$router.push({ name: &#39;Order&#39;, params: { userId: 123 }}) 复制代码 $route.params对象(object)。路由跳转携带参数： this.$router.push({ name: &#39;Order&#39;, params: { userId: 123 }}) console.log(this.$route.params.userId); //123 复制代码 $route.query对象(object)。可访问携带的查询参数： this.$router.push({name: &#39;login&#39;, query:{name: &#39;userName&#39;}}); this.$route.query.name; //you //此时路由为:&quot;http://example.com/#/login?name=userName。&quot; 复制代码 $route.redirectedFrom字符串(string)。重定向来源： 如：{ path: &#39;*&#39;,redirect: {name: &#39;hello&#39;}} 此时访问不存在的路由http://example.com/#/a会重定向到hello， 在hello访问this.$route.redirectedFrom; 输出“/a”。 复制代码 $route.matched数组(array)。当前路由下路由声明的所有信息，从父路由(如果有)到当前路由为止。 $route.hash字符串(string)。当前路径的hash值。 四、vue监听$route的方式watch：{‘$route’ (to, from) {}} 复制代码 route 的变化。watch中监听的对象默认回调函数中的参数值就是newVal,oldVal。作为 $route 属性来说当然也就是 to 和 from 的概念了。Vue用router.push(传参)跳转页面，参数改变，在跳转后的路由观察路由变化，进行页面刷新，可对“from-&gt;to”的过程设置动画效果。该功能的难点就在于怎样获取“上一页”和“下一页”,即怎样分辨是“前进”还是“后退”？例： // watch $route 决定使用哪种过渡 watch:{ &#39;$route&#39; (to, from) { //此时假设从index页面跳转到pointList页面 console.log(to); // &quot;/pointList&quot; console.log(from); // “/index” const routeDeep = [&#39;/&#39;, &#39;/index&#39;,&#39;/pointList&#39;, &#39;/settLement&#39;]; const toDepth = routeDeep.indexOf(to.path) const fromDepth = routeDeep.indexOf(from.path) this.transitionName = toDepth &gt; fromDepth ? &#39;fold-left&#39; : &#39;fold-right&#39; } }, 复制代码 to、from是最基本的路由对象，分别表示从(from)某个页面跳转到(to)另一个页面,to.path（表示要跳转到的路由地址），from.path同理。定义routeDeep数组，将路由目录按层级依次排序(暂不考虑嵌套路由的情况)，复杂单页应用里，同一层级（如同一页面上的多个导航按钮）顺序随意，然后依次排列每个导航的下一页、下下页…即保证每个“上一页”在“下一页”前面。总结下来就是：按照routeDeep数组里定义的路由目录的顺序，“toDepth &gt; fromDepth”表示“上一页”跳转到“下一页”，同理可由此判断是“前进”还是“后退”。 五、Vue2.0中transition组件的使用&lt;transition :name=&quot;transitionName&quot;&gt; &lt;router-view class=&quot;view app-view&quot;&gt;&lt;/router-view&gt; &lt;/transition&gt; 复制代码 transition中有name属性用于替换vue钩子函数中的类名。 transition中只能有一个子元素并且该子元素需要有v-show或者v-if来控制是否显示。 过渡CSS类名transition中的name属性用于 替换 vue钩子函数中的类名transitionName- transitionName-enter: 定义进入过渡的开始状态。在元素被插入时生效，在下一个帧移除。 transitionName-enter-active: 定义进入过渡的结束状态。在元素被插入时生效，在transition/animation完成之后移除。 transitionName-leave:定义离开过渡的开始状态。在离开过渡被触发时生效，在下一个帧移除。 transitionName-leave-active: 定义离开过渡的结束状态。在离开过渡被触发时生效，在transition/animation完成之后移除。 this.transitionName = toDepth &gt; fromDepth ? &#39;fold-left&#39; : &#39;fold-right&#39; 复制代码 在“watch $route”中，判断页面跳转的“前进”和“后退”时，决定用不同的过渡效果（fold-left还是fold-right）。 六、animation、transform动画效果实现在上一个主题中，判断页面跳转路径之后，为两种跳转的transition设置不同的类名“fold-left”、“fold-right”。然后在CSS中，为两种类名设置不同的动画效果(这里以“左滑动”和“右滑动”为例)： .fold-left-enter-active { animation-name: fold-left-in; animation-duration: .3s; } .fold-left-leave-active { animation-name: fold-left-out; animation-duration: .3s; } .fold-right-enter-active { animation-name: fold-right-in; animation-duration: .3s; } .fold-right-leave-active { animation-name: fold-right-out; animation-duration: .3s; } 复制代码 animation 属性是一个简写属性，用于设置六个动画属性： 值 描述 animation-name 规定需要绑定到选择器的 keyframe 名称。 animation-duration 规定完成动画所花费的时间，以秒或毫秒计。 animation-timing-function 规定动画的速度曲线。 animation-delay 规定在动画开始之前的延迟。 animation-iteration-count 规定动画应该播放的次数。 animation-direction 规定是否应该轮流反向播放动画。 @keyframes fold-left-in { 0% { transform: translate3d(100%, 0, 0); } 100% { transform: translate3d(0, 0, 0); } } @keyframes fold-left-out { 0% { transform: translate3d(0, 0, 0); } 100% { transform: translate3d(-100%, 0, 0); } } 复制代码 根据CSS3 @keyframes规则，创建动画。创建动画的原理即将一套CSS样式逐渐变化为另一套样式。在动画过程中，能够多次改变这套CSS样式。可以“百分比”来规定改变发生的时间，或者通过关键词“from”和“to”，等价于“0%”(动画的开始时间)和“100%”(动画的结束时间)。一般为了获得最佳的浏览器支持，应该始终定义0%和100%选择器。transform属性向元素应用2D或3D转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。translate3d(x,y,z)定义3D转换，如transform：translate3d(100%, 0, 0)只改变了x的值，即代表横向左滑动，同理可相应推出其他情况。 总结以上就是vue页面跳转动画效果功能实现的6个步骤，即这个功能中所含括的6个大知识点，当然其中还包括许多扩展的知识点，学无止境，需慢慢深入挖掘…","categories":[{"name":"前端","slug":"前端","permalink":"https://getupyouwhat.github.io/categories/前端/"}],"tags":[{"name":"分享","slug":"分享","permalink":"https://getupyouwhat.github.io/tags/分享/"},{"name":"技术","slug":"技术","permalink":"https://getupyouwhat.github.io/tags/技术/"}]},{"title":"分页算法","slug":"fy","date":"2018-09-25T07:45:14.000Z","updated":"2018-09-26T09:16:56.232Z","comments":true,"path":"2018/09/25/fy/","link":"","permalink":"https://getupyouwhat.github.io/2018/09/25/fy/","excerpt":"","text":"*分页插件，直接复制即可const makeResult = (total,cur,around) =&gt; { let result = []; let baseCount = around * 2 + 1 + 2 + 2 + 2; //总共元素个数 let surplus = baseCount - 4; //只出现一个省略号 剩余元素个数 let startPosition = 1 + 2 + around,endPosition = total - 2 - around; if(total &lt;= baseCount - 2){ //全部显示 不出现省略号 result = Array.from({xlength: total}, (v, i) =&gt; i + 1); }else{ //需要出现省略号 if(cur &lt;= startPosition){ //1.只有后面出现省略号 result = [...Array.from({length: surplus}, (v, i) =&gt; i + 1),&quot;...&quot;,total] }else if(cur &gt;= endPosition) { //2.只有前边出现省略号 result = [1,&#39;...&#39;,...Array.from({length: surplus}, (v, i) =&gt; total - surplus + i + 1)] }else{ //3.两边都有省略号 result = [1,&#39;...&#39;,...Array.from({length: around * 2 + 1}, (v, i) =&gt; cur - around + i),&#39;...&#39;,total] } } return result //返回一个数组 }","categories":[{"name":"前端","slug":"前端","permalink":"https://getupyouwhat.github.io/categories/前端/"}],"tags":[{"name":"分享","slug":"分享","permalink":"https://getupyouwhat.github.io/tags/分享/"},{"name":"原生","slug":"原生","permalink":"https://getupyouwhat.github.io/tags/原生/"}]}]}